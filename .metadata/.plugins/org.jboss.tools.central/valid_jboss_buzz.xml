<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><title>JBoss Tools Aggregated Feed</title><link rel="alternate" href="http://tools.jboss.org" /><subtitle>JBoss Tools Aggregated Feed</subtitle><dc:creator>JBoss Tools</dc:creator><entry><title type="html">Serverless Workflow Validations</title><link rel="alternate" href="https://blog.kie.org/2023/01/serverless-workflow-validations.html" /><author><name>Saravana Balaji</name></author><id>https://blog.kie.org/2023/01/serverless-workflow-validations.html</id><updated>2023-01-27T19:24:27Z</updated><content type="html">Writing a Serverless Workflow that matches with the specification’s rules and schema can require some documentation reading, which demands a few hours. To facilitate that, we have implemented a validation mechanism on our Serverless Workflow Editor, that checks your JSON and YAML files against Serverless Workflow specifications schema and also provides some custom validations in addition to it, that will be detailed below. REQUIREMENTS * (1.66.0+) * (0.26.0) The contains a ready-to-use online version of the Serverless Workflow Editor, where this new feature can be tried by using one of the provided samples or creating a new workflow. SERVERLESS WORKFLOW LANGUAGE SERVICE AND VALIDATION The validation mechanism consists of a dedicated language service for Serverless Workflow, which uses existing JSON and YAML language services as a base and is customized on top of it with the Serverless Workflow specification validation. This feature is provided in both Serverless Logic Web Tools and the built-in editor in the . The validated rules include schema validation and some custom validations, which helps in validating extensive Serverless Workflow nodes like functions, states, events etc. The validation results are highlighted immediately in the editor with a proper message when you hover the error. They can also be seen at the problems section in VS Code or Web Tools. CREATE AND VALIDATE A SERVERLESS WORKFLOW FILE Let’s create a fresh Serverless Workflow from scratch and see how validation works. Create a new file with the ".sw.json” extension. After opening the file in the editor, it will contain an option “Create a Serverless Workflow” at the top. When clicked, it will create a Serverless Workflow specification template, which can also be achieved by using the keyboard shortcut Ctrl + Space. Your workflow can be built on top of this template. You can also check out some interesting Serverless Workflow examples from the repository. SCHEMA VALIDATION The schema validation in Serverless Workflow language service matches the workflow against the schema as per the specification v0.8 released by CNCF. This validation does some strict type checks on every property of the workflow. Schema Validation CUSTOM VALIDATION Serverless Workflow Editor offers some custom validations, which validates the values assigned to Serverless Workflow nodes like functions, states, events etc. This check also includes validating refs like eventRefs, functionRefs, subFlowRefs etc, which comes in handy in assigning the correct references to every property. Let us see how the editor implies custom validations with the example of functions node. VALIDATING FUNCTION NODE First let’s understand the FunctionRef definition a bit. FunctionRef definition can have two types, either string or object. If string, it defines the name of the referenced function from the functions array. "functions": [ { "name": "myFunction", "operation": "localhost#operation", "type": "rest } ], "states": [ { "name": "CheckInbox", "type": "operation", "actionMode": "sequential", "actions": [ { "functionRef": "myFunction" } ], "transition": "SendTextForHighPriority" } ] Similarly, If you need to define parameters in your functionRef definition, you can define it with its object type which has the properties like refName, arguments, selectionSet, invoke. "functions": [ { "name": "checkFundsAvailabe", "operation": "localhost#operation", "type": "rest } ], "state": [ { "refName": "checkFundsAvailabe", "arguments": { "account": { "id": "${ .accountId }" }, "forAmount": "${ .payment.amount }", "insufficientMessage": "The requested amount is not available." } } ] The editor automatically does this extensive validation by the time you enter a value in its properties. It checks if the referenced function name is already part of the functions array and displays a warning if it is not present. Validation in JSON file Validation in YAML file VALIDATING OTHER PROMINENT NODES Similar to the functions node, the editor also validates workflow nodes like Auth, Retries, Subflows, Events, States and others. The type checks of these nodes are done by schema validation, while the references passed are validated by the custom validations implemented in addition to it. The detected errors are highlighted immediately in the editor on both Web Tools and the VS Code extension. Validating events, errors, retries nodes That is all for now, the extension is already available at the . And stay tuned for our next releases! The post appeared first on .</content><dc:creator>Saravana Balaji</dc:creator></entry><entry><title type="html">First Virtual Technical Exploration for IBM Business Automation Manager Open Edition on February 8 (EMEA time-zone)</title><link rel="alternate" href="https://blog.kie.org/2023/01/first-virtual-technical-exploration-for-ibm-business-automation-manager-open-edition-on-february-8-emea-time-zone.html" /><author><name>Reinhold Engelbrecht</name></author><id>https://blog.kie.org/2023/01/first-virtual-technical-exploration-for-ibm-business-automation-manager-open-edition-on-february-8-emea-time-zone.html</id><updated>2023-01-26T15:54:14Z</updated><content type="html">Karina Varela and myself would like to invite you to this free technical exploration (with hands-on labs) on IBM Business Automation Manager Open Edition (BAM) which is the new name for the former Red Hat PAM/DM products that have recently moved to the IBM Business Automation portfolio. After this session, you will have a good understanding of what this transition means for you. At the same time, you will get familiar with Kogito and design, build and deploy a simple Kogito automation project in OpenShift. The event that is targeted at an European, Middle East and Africa audience. It is also a good chance to get any questions related to the transition answered. You will need to have your computer at hand for accessing the hands-on labs in the IBM Cloud (any operating system, just browser access is needed). As we expect a high interest in this technical exploration and the number of participants is limited due to the hands-on exercises, please fast to secure your seat. AGENDA (STARTING AT 9:30 CET) * IBM Business Automation Manager Open Edition – What the Product Transition Means for You * Overview of cloud-native business automation with Kogito * Hands-on lab: From modelling to testing and deploying a business automation in OpenShift * Demo: Extending the solution with Robotic Process Automation (RPA) * Some other Business Automation capabilities complimenting IBM Business Automation Manager Open Edition * Closing INSTRUCTORS * Fadi Sandakly, Nigel Crowther, Reinhold Engelbrecht – IBM Business Automation Technical Sales EMEA The post appeared first on .</content><dc:creator>Reinhold Engelbrecht</dc:creator></entry><entry><title type="html">This Week in JBoss - 26 January 2023</title><link rel="alternate" href="https://www.jboss.org/posts/weekly-2023-01-26.html" /><category term="ansible" /><category term="quarkus" /><category term="java" /><category term="jbang" /><category term="infinispan" /><category term="wildfly" /><category term="cloud-native" /><category term="kia" /><category term="keycloak" /><category term="kafka" /><author><name>Don Naro</name><uri>https://www.jboss.org/people/don-naro</uri><email>do-not-reply@jboss.com</email></author><id>https://www.jboss.org/posts/weekly-2023-01-26.html</id><updated>2023-01-26T00:00:00Z</updated><content type="html">&lt;article class="" data-tags="ansible, quarkus, java, jbang, infinispan, wildfly, cloud-native, kia, keycloak, kafka"&gt; &lt;h1&gt;This Week in JBoss - 26 January 2023&lt;/h1&gt; &lt;p class="preamble"&gt;&lt;/p&gt;&lt;p&gt;Hi everyone! It’s great to be back and bringing you another edition of the JBoss Editorial. As always there’s a lot of exciting news and updates from JBoss communities, so let’s dive in.&lt;/p&gt;&lt;p&gt;&lt;/p&gt; &lt;div class="sect1"&gt; &lt;h2 id="_release_roundup"&gt;Release roundup&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;div class="ulist square"&gt; &lt;ul class="square"&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://quarkus.io/blog/quarkus-2-16-0-final-released/"&gt;Quarkus 2.16.0.Final&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://quarkus.io/blog/quarkus-3-0-0-alpha3-released/"&gt;Quarkus 3.0.0.Alpha3&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://www.wildfly.org/news/2023/01/18/WildFly2613-Released/"&gt;WildFly 26.1.3&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://www.keycloak.org/2023/01/keycloak-2003-released"&gt;Keycloak 20.0.3&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://infinispan.org/download/"&gt;Infinispan 14.0.6.Final&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="sect1"&gt; &lt;h2 id="_deploying_a_wildfly_cluster_using_ansible"&gt;Deploying a WildFly cluster using Ansible&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;p&gt;&lt;a href="https://www.wildfly.org/news/2023/01/10/ansible-wildfly/"&gt;Deploying a WildFly 27.0.1 cluster using Ansible&lt;/a&gt;, by Romain Pelisse&lt;/p&gt; &lt;p&gt;Romain treats us to a brief demonstration that uses Ansible to effortlessly set up a WildFly cluster. Romain uses a short, simple playbook that fully automates his deployment and really shows how Ansible collections can greatly simplify configuration and reduce the time it takes to create large clusters with hundreds of nodes.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="sect1"&gt; &lt;h2 id="_listing_maven_local_artifacts_with_jbang"&gt;Listing Maven local artifacts with JBang&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;p&gt;&lt;a href="http://www.mastertheboss.com/java/how-to-list-maven-local-artifacts-using-jbang/"&gt;How to list Maven local artifacts using JBang&lt;/a&gt;, by Francesco Marchioni&lt;/p&gt; &lt;p&gt;I have to say I’m a huge fan of JBang. What’s not to love about an easy-to-use tool that makes scripting with Java a breeze? When I noticed the title of Francesco’s post, I clicked it immediately and dug right in. It did not disappoint and showed a neat JBang CLI script that uses picocli libraries to find the Maven versions of an artifact in your local repository.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="sect1"&gt; &lt;h2 id="_a_look_at_the_apache_kafka_landscape"&gt;A look at the Apache Kafka landscape&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;p&gt;&lt;a href="http://www.ofbizian.com/2023/01/apache-kafka-landscape.html"&gt;Apache Kafka Landscape&lt;/a&gt;, by Bilgin Ibryam&lt;/p&gt; &lt;p&gt;Bilgin’s post is a great resource for anyone exploring the Apache Kafka ecosystem and provides a lot of time-saving data around various projects, tools, and services related to Kafka.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="sect1"&gt; &lt;h2 id="_quickly_deploying_dashboards_to_github_pages"&gt;Quickly deploying dashboards to GitHub pages&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;p&gt;&lt;a href="https://blog.kie.org/2023/01/deploying-dashbuilder-dashboards.html"&gt;Deploying Dashbuilder Dashboards&lt;/a&gt;, by William Siqueira&lt;/p&gt; &lt;p&gt;William delivers a snappy article that shows you how to publish Dashbuilder dashboards and easily make them available to users in almost no time at all.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="sect1"&gt; &lt;h2 id="_quarkus_native_adopts_adaptive_gc_policy"&gt;Quarkus native adopts adaptive GC policy&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;p&gt;&lt;a href="https://quarkus.io/blog/native-adopts-adaptive-gc-policy/"&gt;Quarkus Native adopts Adaptive GC policy&lt;/a&gt;, by Galder Zamarreño&lt;/p&gt; &lt;p&gt;Galder’s informative post takes us through an examination of the recent change to the garbage collection policy for Quarkus native applications. The change aligns with GraalVM’s default "adaptive" GC policy to provide a better out of the box experience. Galder shows us in spectacular detail how this change brings about more consistent and predictable runtime performance.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="sect1"&gt; &lt;h2 id="_event_driven_ansible_office_hours"&gt;Event-Driven Ansible Office Hours&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;p&gt;&lt;a href="https://github.com/ansible/event-driven-ansible#office-hours"&gt;Event-driven Ansible Office Hours&lt;/a&gt;&lt;/p&gt; &lt;p&gt;Surely by now you’ve heard of Event-Driven Ansible but maybe you only have a rough idea of how the technology works? Well, great news!&lt;/p&gt; &lt;p&gt;The team have started office hours to demo and explain how Event-Driven Ansible allows you to subscribe to an event-listening source and then quickly and easily automate tasks that respond to those events. Follow the link above to find the latest webinar and learn from the community.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="sect1"&gt; &lt;h2 id="_youtube_videos"&gt;YouTube videos&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;p&gt;Definitely catch the replay of &lt;a href="https://youtu.be/qcjrGlRimYU"&gt;Quarkus Insights #115: What’s new in Infinispan?&lt;/a&gt; if you haven’t already watched it.&lt;/p&gt; &lt;p&gt;Also check out Sean Cavanaugh’s demo video, &lt;a href="https://youtu.be/aqQq5vD8-n0"&gt;Getting started with Event-Driven Ansible and Ansible Rulebooks&lt;/a&gt;.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="sect1"&gt; &lt;h2 id="_see_you_next_time"&gt;See you next time&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;p&gt;&lt;em&gt;Hope you enjoyed this edition. Please join us again in two weeks for our JBoss editorial!&lt;/em&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="author"&gt; &lt;pfe-avatar pfe-shape="circle" pfe-pattern="squares" pfe-src="/img/people/don-naro.png"&gt;&lt;/pfe-avatar&gt; &lt;span&gt;Don Naro&lt;/span&gt; &lt;/div&gt;&lt;/article&gt;</content><dc:creator>Don Naro</dc:creator></entry><entry><title type="html">REST Crud Application using Quarkus and Vue.js</title><link rel="alternate" href="http://www.mastertheboss.com/soa-cloud/quarkus/jax-rs-crud-application-using-quarkus-and-vue-js/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/soa-cloud/quarkus/jax-rs-crud-application-using-quarkus-and-vue-js/</id><updated>2023-01-25T15:01:05Z</updated><content type="html">This article shows how to run a Quarkus 3 application using Jakarta REST Service and a Vue.js front-end. The example application will wrap the CRUD method of the endpoint with equivalent Vue.js functions. Let’s get started ! Pre-requisites: You should be familiar with REST Services and VueJS Web interfaces. If you are new to that, ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title>Introducing the new Red Hat Enterprise Linux download experience</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/01/25/new-red-hat-enterprise-linux-download-experience" /><author><name>Nikhil Mungale, Alex Krikos</name></author><id>bff458e5-5138-484f-80f0-c2a1461eadc4</id><updated>2023-01-25T12:00:00Z</updated><published>2023-01-25T12:00:00Z</published><summary type="html">&lt;p&gt;In today's age of hyperscalers and hybrid cloud environments, developers like you need to obtain the appropriate Red Hat Enterprise Linux (RHEL) image based on the desired deployment destination. Developers want choices for their download experience. We are excited to introduce three new options that improve the traditional experience of downloading a RHEL ISO image.&lt;/p&gt; &lt;h2&gt;3 New options to download RHEL&lt;/h2&gt; &lt;p&gt;Now developers can access all vital documentation related to &lt;a href="https://developers.redhat.com/products/rhel/download"&gt;newly enabled RHEL download options&lt;/a&gt; on the same page, including installation, workstation, and image builder guides. This new download experience will help you quickly download and configure RHEL so you can focus on building applications.&lt;/p&gt; &lt;p&gt;In addition to downloading a RHEL ISO image from &lt;a href="https://developers.redhat.com/products/rhel/download"&gt;Red Hat Developer&lt;/a&gt;, there are three new ways to access Red Hat Enterprise Linux:&lt;/p&gt; &lt;h3&gt;1. Build public and private cloud-ready RHEL images&lt;/h3&gt; &lt;p&gt;Using the Red Hat Enterprise Linux image builder, you can now build hyperscaler images for AWS, GCP, and Microsoft Azure and directly deploy them to your public cloud. Plus, you can build images for VMware infrastructure and .qcow2 images and deploy them in any virtual environment.&lt;/p&gt; &lt;h3&gt;2. Access the RHEL server ISO and workstation&lt;/h3&gt; &lt;p&gt;Download the RHEL server ISO and configure workstations to build applications on x86_64 and ARM architectures. By default, you will have access to the most current RHEL versions on the download page. You can also download older RHEL versions from a table on the same page.&lt;/p&gt; &lt;h3&gt;3. Obtain Red Hat Universal Base Images (UBI)&lt;/h3&gt; &lt;p&gt;Now you can access UBI instructions on the RHEL download page. Red Hat Universal Base Images are OCI-compliant container base operating system images with complementary runtime languages and freely redistributable packages. Built from portions of Red Hat Enterprise Linux like previous RHEL base images, UBIs are available in the &lt;a href="https://access.redhat.com/containers/"&gt;Red Hat Container Catalog&lt;/a&gt;. You can execute UBI instructions for their specific use with Podman, Docker, or Red Hat OpenShift.&lt;/p&gt; &lt;h2&gt;Secure RHEL and keep it up to date&lt;/h2&gt; &lt;p&gt;Another essential addition to the new RHEL download page is direct access to Red Hat Insights, included in the &lt;a href="https://developers.redhat.com/articles/faqs-no-cost-red-hat-enterprise-linux"&gt;Red Hat Developer Subscription for Individuals&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Red Hat Insights is a powerful tool for developers to manage their system and keep it up-to-date with the latest advisories, patches, and system updates. This managed service continuously analyzes platforms and applications to help enterprises manage hybrid cloud environments. Insights uses predictive analytics and deep domain expertise to reduce complex operational tasks from hours to minutes. It also identifies security and performance risks, tracks licenses, and manages costs. As part of the new RHEL download experience, you can now directly access Red Hat Insights from the RHEL download page and secure your RHEL from the &lt;a href="https://console.redhat.com/insights/dashboard"&gt;Insights dashboard&lt;/a&gt;. You can access the image builder without starting the Red Hat Insights trial by selecting &lt;strong&gt;Not Now&lt;/strong&gt; on the Red Hat Insights trial pop-up on the console.&lt;/p&gt; &lt;h2&gt;Learn how to develop applications on RHEL&lt;/h2&gt; &lt;p&gt;After you download and securely configure Red Hat Enterprise Linux the way you want, the next step is to &lt;a href="https://developers.redhat.com/products/rhel/getting-started"&gt;build, deploy, and manage&lt;/a&gt; your applications with the latest runtimes and developer tools. You can run your applications anywhere from edge to the cloud with custom cloud images and UBI, using Red Hat tools to deploy on bare metal or in a virtual environment. You can also continuously analyze applications with Red Hat Insights to predict risks and recommend actions.&lt;/p&gt; &lt;p&gt;Check out Red Hat's hands-on labs for all skill levels to learn more. The labs include: &lt;a href="https://developers.redhat.com/learn/lessons/linux-commands?intcmp=7013a0000026UTXAA2"&gt;useful Linux commands&lt;/a&gt;, &lt;a href="https://developers.redhat.com/learn/installing-software-using-package-managers?intcmp=7013a0000026UTXAA2"&gt;Install software using package managers&lt;/a&gt;, and &lt;a href="https://developers.redhat.com/learn/lessons/deploying-containers-podman?intcmp=7013a0000026UTXAA2"&gt;Deploying containers using container tools [podman]&lt;/a&gt;. Try these labs to see your favorite products in action.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/01/25/new-red-hat-enterprise-linux-download-experience" title="Introducing the new Red Hat Enterprise Linux download experience"&gt;Introducing the new Red Hat Enterprise Linux download experience&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Nikhil Mungale, Alex Krikos</dc:creator><dc:date>2023-01-25T12:00:00Z</dc:date></entry><entry><title type="html">Quarkus Native adopts Adaptive GC policy</title><link rel="alternate" href="https://quarkus.io/blog/native-adopts-adaptive-gc-policy/" /><author><name>Galder Zamarreño</name></author><id>https://quarkus.io/blog/native-adopts-adaptive-gc-policy/</id><updated>2023-01-25T00:00:00Z</updated><content type="html">Starting with Quarkus 2.13.6.Final, the native runtime garbage collection policy switched in order to provide more consistent and predictable runtime performance. This blog post tells the story of this switch. Sometime in 2022 while carrying out some native runtime performance benchmarking we observed that, in constant load plain text benchmarks,...</content><dc:creator>Galder Zamarreño</dc:creator></entry><entry><title>How to generate code using Fabric8 Kubernetes Client</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/01/24/how-generate-code-using-fabric8-kubernetes-client" /><author><name>Rohan Kumar</name></author><id>a977e7ef-34bd-42f9-b316-f52ae8f20006</id><updated>2023-01-24T17:00:00Z</updated><published>2023-01-24T17:00:00Z</published><summary type="html">&lt;p&gt;&lt;a href="https://github.com/fabric8io/kubernetes-client"&gt;Fabric8 Kubernetes Client&lt;/a&gt; provides two ways of interacting with &lt;a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/"&gt;CustomResources&lt;/a&gt; running in any &lt;a href="https://kubernetes.io/"&gt;Kubernetes&lt;/a&gt; cluster:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Typed API (covered in &lt;a href="https://developers.redhat.com/articles/2023/01/04/programming-kubernetes-custom-resources-java"&gt;Part 2&lt;/a&gt;)&lt;/li&gt; &lt;li&gt;Typeless API (covered in &lt;a href="https://developers.redhat.com/articles/2023/01/05/how-use-fabric8-kubernetes-client#"&gt;Part 3&lt;/a&gt;)&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;While typeless API provides a way to deal with CustomResources generically, it’s not always a preferable option for a strongly typed language like Java. Most developers want to use typed API to have complete and type-safe control over their CustomResources.&lt;/p&gt; &lt;p&gt;However, there is one additional step involved in using typed API. It provides POJOs for Kubernetes CustomResource objects. This article showcases how you can automatically generate CustomResourceDefinition-related code using tools offered by the &lt;a href="https://github.com/fabric8io/kubernetes-client"&gt;Fabric8 Kubernetes Client&lt;/a&gt; library.&lt;/p&gt; &lt;p&gt;This is the fourth installment in the following series of articles:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Part 1: &lt;a href="https://developers.redhat.com/articles/2023/01/04/how-use-fabric8-java-client-kubernetes"&gt;How to use Fabric8 Java Client with Kubernetes&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Part 2: &lt;a href="https://developers.redhat.com/articles/2023/01/04/programming-kubernetes-custom-resources-java"&gt;Programming Kubernetes custom resources in Java&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Part 3: &lt;a href="https://developers.redhat.com/articles/2023/01/05/how-use-fabric8-kubernetes-client#"&gt;How to use Kubernetes dynamic client with Fabric8&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Part 4: How to generate code using Fabric8 Kubernetes Client&lt;/li&gt; &lt;li&gt;Part 5: &lt;a href="https://developers.redhat.com/articles/2023/01/24/how-write-tests-fabric8-kubernetes-client"&gt;How to write tests with Fabric8 Kubernetes Client&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;h2&gt;2 CRD generation options&lt;/h2&gt; &lt;p&gt;There are two possible approaches to generating code while using custom resources:&lt;/p&gt; &lt;ol&gt;&lt;li&gt;Users coming from a Java background would have more confidence in writing Java classes than in writing CRD YAML, which is error-prone. They would prefer to generate CRD Yaml from the Java POJO they wrote.&lt;/li&gt; &lt;li&gt;It is also possible that there is an existing CRD YAML file for which you can generate Java POJOs.&lt;/li&gt; &lt;/ol&gt;&lt;p&gt;Fabric8 Kubernetes Client provides tooling for both of these approaches via &lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/doc/CRD-generator.md"&gt;CRD Generator&lt;/a&gt; and &lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/doc/java-generation-from-CRD.md"&gt;Java Generator&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;Let’s take an example of the Book CustomResource we used in part 2, &lt;a href="https://developers.redhat.com/articles/2023/01/04/programming-kubernetes-custom-resources-java"&gt;Programming Kubernetes custom resources in Java&lt;/a&gt;, to see both approaches to generating Java POJOs from CRD YAML and vice versa.&lt;/p&gt; &lt;h2&gt;Generating CRD POJOs from CRD YAML&lt;/h2&gt; &lt;p&gt;Consider a scenario with only CRD YAML manifest for the Book CustomResource. We want to automatically generate Java POJOs for Book CustomResource. We’ll be using &lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/doc/java-generation-from-CRD.md"&gt;Fabric8 Java Generator&lt;/a&gt; to do this. We’ll be using its &lt;a href="https://search.maven.org/artifact/io.fabric8/java-generator-maven-plugin/6.3.1/maven-plugin"&gt;Java Generator Maven Plugin&lt;/a&gt; to generate Java POJOs from YAML during build time.&lt;/p&gt; &lt;p&gt;Let’s start with a basic maven project and place our Book CustomResource YAML in our project’s resources folder. If you don’t have an existing project, you can clone this &lt;a href="https://github.com/rohanKanojia/kubernetes-client-demo/tree/master/fabric8-crd-java-generator-demo"&gt;GitHub repository&lt;/a&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;fabric8-crd-java-generator-demo : $ tree src/main/resources/ src/main/resources/ └── crd └── book-crd.yaml &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In our project’s &lt;code&gt;pom.xml&lt;/code&gt; let’s add Fabric8 Java Generator Maven Plugin configuration to generate Java POJOs for CRD YAML present in &lt;code&gt;src/main/resources&lt;/code&gt; folder:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-xml"&gt;&lt;plugin&gt; &lt;groupId&gt;io.fabric8&lt;/groupId&gt; &lt;artifactId&gt;java-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${fabric8.version}&lt;/version&gt; &lt;configuration&gt; &lt;!-- 1 --&gt; &lt;source&gt;${project.basedir}/src/main/resources/crd/book-crd.yaml&lt;/source&gt; &lt;!-- 2 --&gt; &lt;extraAnnotations&gt;true&lt;/extraAnnotations&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;By providing this plugin configuration, we’re instructing Java Generator Maven Plugin to do the following:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Pick &lt;code&gt;book-crd.yaml&lt;/code&gt; file as a source file for generating CustomResource POJOs.&lt;/li&gt; &lt;li&gt;Add extra annotations to generated classes that can be processed by &lt;a href="https://github.com/sundrio/sundrio"&gt;Sundrio&lt;/a&gt; to add additional helper builders and fluent classes. This would also require &lt;a href="https://search.maven.org/artifact/io.sundr/builder-annotations/0.93.2/jar"&gt;Sundrio&lt;/a&gt; and &lt;a href="https://search.maven.org/artifact/org.projectlombok/lombok/1.18.24/jar"&gt;lombok&lt;/a&gt; dependencies added to the project.&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;Compile the project as follows:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;fabric8-crd-java-generator-demo : $ mvn clean install&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Upon running &lt;code&gt;mvn clean install&lt;/code&gt;, you can see that Book CustomResource POJOs are automatically generated in&lt;code&gt;target/generated-sources/java/&lt;/code&gt;. This is the default location of generated sources. If you want to generate these POJOs in some other directory, you can provide &lt;code&gt;target &lt;/code&gt;in Java Generator Maven Plugin configuration section or via &lt;code&gt;fabric8.java-generator.target &lt;/code&gt;property.&lt;/p&gt; &lt;p&gt;Java Generator Maven Plugin also automatically adds these generated classes to maven source paths. So you don’t have to worry about adding extra configuration to add these generated classes to the maven source path.&lt;/p&gt; &lt;p&gt;There are also some helper classes generated in &lt;code&gt;target/generated-sources/java/&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;fabric8-crd-java-generator-demo : $ tree target/generated-sources/java/ target/generated-sources/java/ └── io └── fabric8 └── demo └── generator └── v1alpha1 ├── Book.java ├── BookSpec.java └── BookStatus.java 5 directories, 3 files fabric8-crd-java-generator-demo : $ tree target/generated-sources/annotations/ target/generated-sources/annotations/ └── io └── fabric8 └── demo └── generator └── v1alpha1 ├── BookBuilder.java ├── BookFluentImpl.java ├── BookFluent.java ├── BookSpecBuilder.java ├── BookSpecFluentImpl.java ├── BookSpecFluent.java ├── BookStatusBuilder.java ├── BookStatusFluentImpl.java └── BookStatusFluent.java 5 directories, 9 files &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You can go ahead and start writing code based on these generated Book POJOs. Java Generator Maven Plugin allows various configuration options to configure source generation. You can take a look here at the &lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/java-generator/maven-plugin/src/main/java/io/fabric8/java/generator/maven/plugin/JavaGeneratorMojo.java#L42"&gt;source code&lt;/a&gt; or &lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/doc/java-generation-from-CRD.md"&gt;documentation&lt;/a&gt; for more details.&lt;/p&gt; &lt;p&gt;You can find the source code for this in this &lt;a href="https://github.com/rohanKanojia/kubernetes-client-demo/tree/master/fabric8-crd-java-generator-demo"&gt;GitHub repository&lt;/a&gt;.&lt;/p&gt; &lt;h2&gt;Generating CRD Yaml from POJOs&lt;/h2&gt; &lt;p&gt;Now let’s take a look at the opposite scenario. We already have Java sources for the Book CustomResource but we want to generate CustomResourceDefinition YAML manifests.&lt;/p&gt; &lt;p&gt;We have our POJOs in &lt;code&gt;src/main/java &lt;/code&gt; folder as usual (see &lt;a href="https://github.com/rohanKanojia/kubernetes-client-demo/tree/master/fabric8-java-crd-yaml-generator-demo"&gt;GitHub repository&lt;/a&gt; for source code).&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;fabric8-java-crd-yaml-generator-demo : $ tree src/main/java/ src/main/java/ └── io └── fabric8 └── demo └── crd └── v1alpha1 ├── Book.java ├── BookSpec.java └── BookStatus.java 5 directories, 3 files &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;We’ll be using &lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/doc/CRD-generator.md"&gt;Fabric8 Crd Generator&lt;/a&gt; to generate CRD Yaml files for Book CustomResource. It’s available as a &lt;a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html"&gt;Java Annotation Processor&lt;/a&gt;, so you can simply add it as a dependency in your project, and you should be good to go.&lt;/p&gt; &lt;p&gt;Add Fabric8 Crd Generator dependency to your &lt;code&gt;pom.xml&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-xml"&gt;&lt;dependency&gt; &lt;groupId&gt;io.fabric8&lt;/groupId&gt; &lt;artifactId&gt;crd-generator-apt&lt;/artifactId&gt; &lt;version&gt;${fabric8.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Compile project:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;fabric8-java-crd-yaml-generator-demo : $ mvn clean install … [INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ fabric8-java-crd-yaml-generator-demo --- [INFO] Changes detected - recompiling the module! [INFO] Compiling 3 source files to /home/rokumar/work/repos/kubernetes-client-demo/fabric8-java-crd-yaml-generator-demo/target/classes [INFO] Generating CRD books.testing.fabric8.io: [INFO] - v1beta1 -&gt; /home/rokumar/work/repos/kubernetes-client-demo/fabric8-java-crd-yaml-generator-demo/target/classes/META-INF/fabric8/books.testing.fabric8.io-v1beta1.yml [INFO] - v1 -&gt; /home/rokumar/work/repos/kubernetes-client-demo/fabric8-java-crd-yaml-generator-demo/target/classes/META-INF/fabric8/books.testing.fabric8.io-v1.yml &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You will notice that during compilation, the Fabric8 Crd Annotation processor generated CustomResourceDefinition YAML files in &lt;code&gt;target/classes/META-INF/fabric8&lt;/code&gt; folder. It picks up all of the classes in the project, which extend &lt;code&gt;io.fabric8.kubernetes.client.CustomResource&lt;/code&gt; and generate CustomResourceDefinition YAML files for each of them.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;fabric8-java-crd-yaml-generator-demo : $ ls target/classes/META-INF/fabric8/ books.testing.fabric8.io-v1beta1.yml  books.testing.fabric8.io-v1.yml&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You will notice that there are two YAML files generated (one with &lt;code&gt;v1&lt;/code&gt; and one with &lt;code&gt;v1beta1&lt;/code&gt; suffix). The &lt;code&gt;v1beta1&lt;/code&gt; is kept for backward compatibility for older Kubernetes Clusters, which only supported &lt;code&gt;apiextensions.k8s.io/v1beta1&lt;/code&gt; CustomResourceDefinitions. For most cases, you would most likely be working with the &lt;code&gt;v1&lt;/code&gt; YAML file.&lt;/p&gt; &lt;p&gt;You can go ahead and inspect the contents of generated CustomResourceDefinition YAML files and use them in your Kubernetes clusters.&lt;/p&gt; &lt;p&gt;For more information about the different configuration options available, check out &lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/doc/CRD-generator.md"&gt;Fabric8 CRD Generator Documentation&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;You can find code for this example in this &lt;a href="https://github.com/rohanKanojia/kubernetes-client-demo/tree/master/fabric8-java-crd-yaml-generator-demo"&gt;GitHub repository&lt;/a&gt;.&lt;/p&gt; &lt;h2&gt;Learn more about Fabric8 Kubernetes Client&lt;/h2&gt; &lt;p&gt;In this blog post, you learned about the code generation capabilities of Fabric8 Kubernetes Client’s tooling in form of &lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/doc/java-generation-from-CRD.md"&gt;Java Generator&lt;/a&gt; and &lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/doc/CRD-generator.md"&gt;CRD Generator&lt;/a&gt;. You can find the code in this &lt;a href="https://github.com/rohanKanojia/kubernetes-client-demo%C2%A0"&gt;GitHub repository&lt;/a&gt;. The next article in my series, &lt;a href="https://developers.redhat.com/articles/2023/01/24/how-write-tests-fabric8-kubernetes-client"&gt;How to write tests with Fabric8 Kubernetes Client&lt;/a&gt;, discusses Fabric8 Kubernetes Client testing libraries, Fabric8 Kubernetes Mock Server, and Fabric8 JUnit5 Extension.&lt;/p&gt; &lt;p&gt;For more information, check out the &lt;a href="https://github.com/fabric8io/kubernetes-client"&gt;Fabric8 Kubernetes Client GitHub&lt;/a&gt; page. Feel free to follow us on these channels:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/tagged/fabric8"&gt;StackOverflow&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/doc/CHEATSHEET.md"&gt;Fabric8 Kubernetes Client CHEATSHEET&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://twitter.com/fabric8io"&gt;Twitter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://gitter.im/fabric8io/kubernetes-client"&gt;Gitter Chat&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/01/24/how-generate-code-using-fabric8-kubernetes-client" title="How to generate code using Fabric8 Kubernetes Client"&gt;How to generate code using Fabric8 Kubernetes Client&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Rohan Kumar</dc:creator><dc:date>2023-01-24T17:00:00Z</dc:date></entry><entry><title type="html">How to create a Java JMS Client for Artemis</title><link rel="alternate" href="http://www.mastertheboss.com/jboss-frameworks/activemq/how-to-create-a-java-jms-client-for-artemis/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/jboss-frameworks/activemq/how-to-create-a-java-jms-client-for-artemis/</id><updated>2023-01-24T14:36:04Z</updated><content type="html">This article will teach you how to write an example Java JMS Client for an Artemis MQ server. We will cover both the configuration of the address in Artemis and a simple Java Client. When working with JMS, destinations such as queues and topics are typically located using JNDI (Java Naming and Directory Interface). The ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title>How to write tests with Fabric8 Kubernetes Client</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/01/24/how-write-tests-fabric8-kubernetes-client" /><author><name>Rohan Kumar</name></author><id>ea063e82-88de-4a1c-9339-a2822addad27</id><updated>2023-01-24T07:00:00Z</updated><published>2023-01-24T07:00:00Z</published><summary type="html">&lt;p&gt;Like regular applications, it is essential to write tests while building applications that interact with the Kubernetes API server (i.e., Kubernetes Operators). However, it is not always possible to have a Kubernetes test environment available for running tests. Also, our tests may require us to satisfy certain prerequisites (some specific Kubernetes version) in order to run successfully.&lt;/p&gt; &lt;p&gt;In this blog post, we will look at testing libraries made available by &lt;a href="https://github.com/fabric8io/kubernetes-client"&gt;Fabric8 Kubernetes Client&lt;/a&gt; and focus mainly on &lt;a href="https://search.maven.org/artifact/io.fabric8/kubernetes-server-mock/6.3.1/jar"&gt;Fabric8 Kubernetes Mock Server&lt;/a&gt; and &lt;a href="https://search.maven.org/artifact/io.fabric8/kubernetes-junit-jupiter/6.3.1/jar"&gt;Fabric8 JUnit5 Extension&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;This article is the final installment in my series:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Part 1: &lt;a href="https://developers.redhat.com/articles/2023/01/04/how-use-fabric8-java-client-kubernetes"&gt;How to use Fabric8 Java Client with Kubernetes&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Part 2:  &lt;a href="https://developers.redhat.com/articles/2023/01/04/programming-kubernetes-custom-resources-java"&gt;Programming Kubernetes custom resources in Java&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Part 3: &lt;a href="https://developers.redhat.com/articles/2023/01/05/how-use-fabric8-kubernetes-client#"&gt;How to use Kubernetes dynamic client with Fabric8&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Part 4: &lt;a href="https://developers.redhat.com/articles/2023/01/24/how-generate-code-using-fabric8-kubernetes-client"&gt;How to generate code using Fabric8 Kubernetes Client&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Part 5: How to write tests with Fabric8 Kubernetes Client&lt;/li&gt; &lt;/ul&gt;&lt;h2&gt;How to write tests using Fabric8 Kubernetes Mock Server&lt;/h2&gt; &lt;p&gt;Since it’s not always possible to have a Kubernetes Cluster available for testing while writing tests, most developers try to mock KubernetesClient calls using mocking frameworks like &lt;a href="https://site.mockito.org/"&gt;Mockito&lt;/a&gt; and &lt;a href="https://jmockit.github.io/"&gt;JMockit&lt;/a&gt;. While this can work for most scenarios, overuse of mocking nested KubernetesClient calls can leave tests cluttered with mock calls and decrease readability.&lt;/p&gt; &lt;p&gt;Fabric8 Kubernetes Client provides a &lt;a href="https://search.maven.org/artifact/io.fabric8/kubernetes-server-mock/6.3.1/jar"&gt;Kubernetes Mock Server&lt;/a&gt; that provides spins up a server during testing that looks very much like a real Kubernetes API server. Based on &lt;a href="https://github.com/square/okhttp/tree/master/mockwebserver"&gt;OkHttp’s MockWebServer&lt;/a&gt;, it tries to emulate the Kubernetes API server’s calls for common operations such as get, list, create, watch, etc., which can be common scenarios while testing Kubernetes applications.&lt;/p&gt; &lt;p&gt;In order to use Kubernetes Mock Server, you need to add the following dependency:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-xml"&gt;&lt;dependency&gt; &lt;groupId&gt;io.fabric8&lt;/groupId&gt; &lt;artifactId&gt;kubernetes-server-mock&lt;/artifactId&gt; &lt;version&gt;${fabric8.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Once added as a dependency, you can start using Kubernetes Mock Server in your tests. Let’s see how we can get started with using Kubernetes Mock Server in our tests.&lt;/p&gt; &lt;p&gt;If you’re using &lt;a href="https://junit.org/junit4/"&gt;JUnit4&lt;/a&gt;, you can add a &lt;a href="https://junit.org/junit4/javadoc/4.12/org/junit/Rule.html"&gt;JUnit Rule&lt;/a&gt; for Kubernetes Mock Server in your test as follows:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;import io.fabric8.kubernetes.client.server.mock.KubernetesServer; public class Foo { @Rule public KubernetesServer crudServer = new KubernetesServer(true, true); // … } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;There are two configurable arguments when initializing Kubernetes Mock Server:&lt;/p&gt; &lt;ol&gt;&lt;li&gt;&lt;strong&gt;Crud:&lt;/strong&gt; Enable Opinionated Kubernetes mock server, where users don’t need to provide expectations for their operations (defaults to false). &lt;/li&gt; &lt;li&gt;&lt;strong&gt;Https:&lt;/strong&gt; Use HTTPS or not (defaults to true).&lt;/li&gt; &lt;/ol&gt;&lt;p&gt;If you’re using &lt;a href="https://junit.org/junit5/"&gt;JUnit5&lt;/a&gt;, you can use the following  @EnableKubernetesMockClient annotation:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;import io.fabric8.kubernetes.client.server.mock.EnableKubernetesMockClient; @EnableKubernetesMockClient class Foo { private KubernetesClient kubernetesClient; private KubernetesMockServer server; // .. } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You can use Kubernetes Mock Server in two modes:&lt;/p&gt; &lt;ol&gt;&lt;li&gt;&lt;strong&gt;CRUD Mode&lt;/strong&gt;: Opinionated Kubernetes Mock Server acts very similar to a real Kubernetes API Server and processes common operations such as get, create, watch, etc.&lt;/li&gt; &lt;li&gt;&lt;strong&gt;Expectations Mode:&lt;/strong&gt; The user defines expectations for Kubernetes Mock Server for API endpoints expected to hit during test execution and defines response elements.&lt;/li&gt; &lt;/ol&gt;&lt;p&gt;I will explain both modes with the help of an example.&lt;/p&gt; &lt;p&gt;Consider an elementary class PodGroupService that manages a group of pods in the currently logged namespace sharing some labels. &lt;/p&gt; &lt;p&gt;Refer to my Kubernetes Client demo &lt;a href="https://github.com/rohanKanojia/kubernetes-client-demo/blob/master/writing-tests-with-fabric8/src/main/java/io/fabric8/demos/tests/mockserver/PodGroupService.java#L23"&gt;PodGroupService.java&lt;/a&gt;.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;package io.fabric8.demos.tests.mockserver; import io.fabric8.kubernetes.client.KubernetesClient; import java.util.Map; public class PodGroupService { private final KubernetesClient kubernetesClient; private final Map&lt;String, String&gt; matchLabels; public PodGroupService(KubernetesClient client, Map&lt;String, String&gt; matchLabels) { this.kubernetesClient = client; this.matchLabels = matchLabels; } public PodList list() { return kubernetesClient.pods().withLabels(matchLabels).list(); } public int size() { return list().getItems().size(); } // Rest of methods } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Next, let’s try to write a test for this size method using Kubernetes Mock Server using both modes.&lt;/p&gt; &lt;h3&gt;CRUD mode&lt;/h3&gt; &lt;p&gt;In CRUD mode, you don’t need to set any expectations. You need to use KubernetesClient assuming a real Kubernetes API server is running in the background. You can see it’s quite transparent and readable:&lt;/p&gt; &lt;p&gt;Refer to &lt;a href="https://github.com/rohanKanojia/kubernetes-client-demo/blob/master/writing-tests-with-fabric8/src/test/java/io/fabric8/demos/tests/mockserver/PodGroupServiceCrudTest.java#L58"&gt;PodGroupServiceCrudTest.java&lt;/a&gt;.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;package io.fabric8.demos.tests.mockserver; import io.fabric8.kubernetes.api.model.PodBuilder; import io.fabric8.kubernetes.client.KubernetesClient; import io.fabric8.kubernetes.client.server.mock.EnableKubernetesMockClient; import io.fabric8.kubernetes.client.server.mock.KubernetesMockServer; import org.junit.jupiter.api.Test; import java.util.Collections; import static org.junit.jupiter.api.Assertions.assertEquals; @EnableKubernetesMockClient(crud = true) class PodGroupServiceCrudTest { private KubernetesClient kubernetesClient; private KubernetesMockServer server; @Test void size_whenPodsWithLabelPresent_thenReturnCount() { // Given Map&lt;String, String&gt; matchLabel = Collections.singletonMap("foo", "bar"); kubernetesClient.pods().resource(createNewPod("p1", matchLabel)).create(); PodGroupService podGroupService = new PodGroupService(kubernetesClient, matchLabel); // When int count = podGroupService.size(); // Then assertEquals(1, count); } } &lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;Expectations mode&lt;/h3&gt; &lt;p&gt;While in Expectations mode, we need to set up expectations for the behavior we want when a certain Kubernetes resource endpoint the KubernetesClient requests:&lt;/p&gt; &lt;p&gt;Refer to the &lt;a href="https://github.com/rohanKanojia/kubernetes-client-demo/blob/master/writing-tests-with-fabric8/src/test/java/io/fabric8/demos/tests/mockserver/PodGroupServiceTest.java#L74"&gt;PodGroupServiceTest.java&lt;/a&gt;.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;package io.fabric8.demos.tests.mockserver; import io.fabric8.kubernetes.api.model.PodBuilder; import io.fabric8.kubernetes.api.model.PodListBuilder; import io.fabric8.kubernetes.client.KubernetesClient; import io.fabric8.kubernetes.client.server.mock.EnableKubernetesMockClient; import io.fabric8.kubernetes.client.server.mock.KubernetesMockServer; import org.junit.jupiter.api.Test; import java.util.Collections; import static java.net.HttpURLConnection.HTTP_OK; import static org.junit.jupiter.api.Assertions.assertEquals; @EnableKubernetesMockClient class PodGroupServiceTest { private KubernetesClient kubernetesClient; private KubernetesMockServer server; @Test void size_whenPodsWithLabelPresent_thenReturnCount() { // Given server.expect().get() .withPath("/api/v1/namespaces/test/pods?labelSelector=foo%3Dbar") .andReturn(HTTP_OK, new PodListBuilder().addToItems( new PodBuilder() .withNewMetadata() .withName("pod1") .addToLabels("foo", "bar") .endMetadata() .build()) .build()) .once(); PodGroupService podGroupService = new PodGroupService(kubernetesClient, Collections.singletonMap("foo", "bar")); // When int count = podGroupService.size(); // Then assertEquals(1, count); } } &lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Writing tests against real Kubernetes clusters&lt;/h2&gt; &lt;p&gt;Apart from Kubernetes Mock Server, Fabric8 Kubernetes Client provides a set of JUnit5 extension annotations that can simplify writing tests against a real Kubernetes Cluster.&lt;/p&gt; &lt;p&gt;To use these JUnit5 annotations, you need to add this dependency:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-xml"&gt;&lt;dependency&gt; &lt;groupId&gt;io.fabric8&lt;/groupId&gt; &lt;artifactId&gt;kubernetes-junit-jupiter&lt;/artifactId&gt; &lt;version&gt;${fabric8.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The following table lists the annotations provided by this dependency:&lt;/p&gt; &lt;div&gt; &lt;table border="1" cellpadding="1" cellspacing="1" width="624"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt; &lt;p&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;p&gt;&lt;code&gt;@KubernetesTest&lt;/code&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;Creates a temporary test namespace and configures a KubernetesClient instance in the test class to use in the tests.&lt;br /&gt;&lt;br /&gt; See &lt;a href="https://github.com/rohanKanojia/kubernetes-client-demo/blob/master/writing-tests-with-fabric8/src/test/java/io/fabric8/demos/tests/e2e/PodGroupServiceIT.java#L28"&gt;example&lt;/a&gt;.&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;p&gt;&lt;code&gt;@LoadKubernetesManifests&lt;/code&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;Apply a YAML file to set up the environment before test execution.&lt;/p&gt; &lt;p&gt;See &lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/kubernetes-itests/src/test/java/io/fabric8/kubernetes/ConfigMapIT.java#L31"&gt;example&lt;/a&gt;.&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;p&gt;&lt;code&gt;@RequireK8sSupport&lt;/code&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;Only execute the test when a specific Kubernetes resource is present in the Kubernetes cluster before test execution. It’s quite helpful in the case of custom resources.&lt;/p&gt; &lt;p&gt;See &lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/kubernetes-itests/src/test/java/io/fabric8/kubernetes/PodEvictIT.java#L38"&gt;example&lt;/a&gt;.&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;p&gt;&lt;code&gt;@RequireK8sVersionAtLeast&lt;/code&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;Only execute test when Kubernetes version is at least specified version.&lt;/p&gt; &lt;p&gt;See &lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/kubernetes-itests/src/test/java/io/fabric8/kubernetes/DryRunIT.java#L32"&gt;example&lt;/a&gt;.&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt; &lt;p&gt; &lt;/p&gt; &lt;p&gt;Now let’s come back to our PodGroupService example and try to write an end-to-end test for the &lt;code&gt;size()&lt;/code&gt; method. You can see it’s very similar to the test we wrote for Kubernetes Mock Server in CRUD mode, but here we’re using the JUnit5 annotations: &lt;a href="https://github.com/rohanKanojia/kubernetes-client-demo/blob/master/writing-tests-with-fabric8/src/test/java/io/fabric8/demos/tests/e2e/PodGroupServiceIT.java#L75"&gt;PodGroupServiceIT.java&lt;/a&gt;.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;package io.fabric8.demos.tests.e2e; // … import io.fabric8.junit.jupiter.api.KubernetesTest; import io.fabric8.junit.jupiter.api.RequireK8sSupport; import io.fabric8.junit.jupiter.api.RequireK8sVersionAtLeast; @KubernetesTest @RequireK8sSupport(Pod.class) @RequireK8sVersionAtLeast(majorVersion = 1, minorVersion = 16) class PodGroupServiceIT { KubernetesClient kubernetesClient; @Test void size_whenPodsPresent_thenReturnActualSize() { // Given PodGroupService podGroupService = new PodGroupService(kubernetesClient, Collections.singletonMap("app", "size-non-zero")); podGroupService.addToGroup(createNewPod("p1", "size-non-zero")); podGroupService.addToGroup(createNewPod("p2", "size-non-zero")); // When int result = podGroupService.size(); // Then assertEquals(2, result); } } &lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Fabric8 Kubernetes series wrap-up&lt;/h2&gt; &lt;p&gt;This concludes my series on Fabric8 Kubernetes Java for developers. This article demonstrated how to write unit and end-to-end tests using testing libraries provided by Fabric8 Kubernetes Client. You can find the code in this &lt;a href="https://github.com/rohanKanojia/kubernetes-client-demo/tree/master/writing-tests-with-fabric8"&gt;GitHub repository&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;For more information, check out the &lt;a href="https://github.com/fabric8io/kubernetes-client"&gt;Fabric8 Kubernetes Client GitHub&lt;/a&gt; page. Feel free to follow us on these channels:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/tagged/fabric8"&gt;StackOverflow&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/doc/CHEATSHEET.md"&gt;Fabric8 Kubernetes Client CHEATSHEET&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://twitter.com/fabric8io"&gt;Twitter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://gitter.im/fabric8io/kubernetes-client"&gt;Gitter Chat&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/01/24/how-write-tests-fabric8-kubernetes-client" title="How to write tests with Fabric8 Kubernetes Client"&gt;How to write tests with Fabric8 Kubernetes Client&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Rohan Kumar</dc:creator><dc:date>2023-01-24T07:00:00Z</dc:date></entry><entry><title type="html">Deploying Dashbuilder Dashboards</title><link rel="alternate" href="https://blog.kie.org/2023/01/deploying-dashbuilder-dashboards.html" /><author><name>William Siqueira</name></author><id>https://blog.kie.org/2023/01/deploying-dashbuilder-dashboards.html</id><updated>2023-01-23T13:50:24Z</updated><content type="html">files are plain YAML which makes it easy to author dashboards using the . The next natural step is to publish this dashboard for public access and this is what we cover in this article! Image Generated usign DALLE-2 WHAT IS DASHBUILDER AFTER ALL? Dashbuilder is a web application that can run dashboards in different modes: EDITOR: In this mode Dashbuilder receives the content dynamically and renders it. It is used embedded in editors; CLIENT: This is the mode that should be used for deployment. Basically you provide your YAML files and configure the path to it in file setup.js. If you map multiple YAML files then Dashbuilder will prompt users to select a dashboard. In Client mode the requirement is to have the dashbuilder static bundle, which is inside the package. But how do you make it available? Let’s explore some alternatives! Deploying to Openshift It is possible to easily deploy to Openshift using the following articles written by my colleagues: * : In this article shows how to create a static web content container image and deploy to OpenShift Sandbox; * : A new feature allows you to run Serverless Logic Web Tools dashboards directly into  Openshift. This feature is described in this article by my colleague DASHBUILDER NPM PROJECT For using NPM with Dashbuilder you need to create a new npm project, then add the dependency “@kie-tools/dashbuilder-client”: npm init npm i @kie-tools/dashbuilder-client npm install The dashbuilder bundle will be available in node_modules/@kie-tools/dashbuilder-client/dist/. You can use scripts or webpack to build the final bundle that should include your setup.js and the YAML files. Here’s a sample package.json {  "name": "dashbuilder-webapp",  "version": "0.0.0",  "description": "Dashbuilder WebApp",  "scripts": {    "bootstrap": "npm install",    "clean": "rm -rf dist/",    "copy:dashbuilder": "cp -r node_modules/@kie-tools/dashbuilder-client/dist/* dist/",    "copy:sources": "cp -r static/* dist",    "build": "npm run clean &amp;amp;&amp; mkdir dist/ &amp;amp;&amp; npm run copy:dashbuilder &amp;amp;&amp; npm run copy:sources",    "server": "npm run build &amp;amp;&amp; cd dist &amp;amp;&amp; http-server -p 8000"  },  "devDependencies": {    "@kie-tools/dashbuilder-client": "^0.26.0",    "http-server": "^14.1.1"  } } Using the package.json from above will allow you to run the following commands: * npm run bootstrap: Inits the project * npm run build: Builds the webapp, which will be available in dist directory; * npm run server: Runs an HTTP server on port 8000 so you can visualize your dashboards The static content from dist  is ready to be deployed in some web server. Let’s explore how to do it with Github Pages. USING GITHUBPAGES To deploy to Github Pages, you need to build the project from the last step and commit the dist content to a Github repository with a branch called gh-pages. Your dashboards will be available in username}.github.io/{repository name} Here’s a template project so you can get started: To use the template above just click on button “Use this template” (make sure to mark “Include all branches”). Then you can either edit the files and push changes to Github and the project will be automatically built and available in username}.github.io/{repository name}.  To use a rich YAML editor you can use : * Setup Your github token following the website instructions; * Import the project; * Edit the files you want and send the changes back to github * Wait a few minutes and the changes will be in your github pages You can see these steps also in the video below The post appeared first on .</content><dc:creator>William Siqueira</dc:creator></entry></feed>
